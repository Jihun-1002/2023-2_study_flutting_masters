# FLUTTER

## 동작 방식

→ 게임 엔진과 비슷

엔진이 코드를 실행시켜준다고 생각하면 됨.

- 운영체제와 소통X
- 엔진이 화면상의 모든 것을 그려냄.
- 엔진 - VM과 비슷

 호스트 os에 의존하지 않아서 모든걸 그려낼 수 있음. 화면 상단에 있는 핸드폰 상태 바도 그려냄. → 렌더링 엔진이 구동 시키 때문이다.

단점: 네이티브(OS)에 존재하는 위젯들을 사용할 수 없어서 앱이 부자연스러워보일 수 있음.

→ react native를 사용하자

### React Native

자바 스크립트가 운영체제와 소통해서 운영체제만의 위젯을 불러올 수 있음.

단 native만의 것을 사용하기 때문에 react native만 사용하면 구현하기 힘들 수 있음.

⇒ 호스트 운영체제의 스타일을 사용하고 싶다→ React native 사용하기

### 만약 디자인을 커스터마이징 하고싶다?

⇒ Flutter 사용하기

## 시작

flutter의 모든것은 Widget임.

### root Widget (기본 설정)

return

- CupertinoApp ⇒ ios
- MaterialApp ⇒ google

→ 무슨 스타일을 사용할 것인지.

어떻게 보이게 하고 싶은지 설정

requierd(필수로 넣어야) → ? 로 인지 아닌지 알 수 있음

<aside>
💡 Ctrl + . → code action 바 나

</aside>

stateful: 사용자가 바꾸는대로 바뀜 → state 사용

→ 살아있음 ⇒ lifecycle

- state

데이터가 바뀔 때 UI가 새로고침됨

→ setState 함수를 이용해 State에게 데이터의 변경 사실을 알림

- setState → build 부분을 다시 실행

statelesswidget: UI만 보여줌

### (buildcontext context)

context: 함수 이전에 있는 모든 상위 요소(부모 요소)들에 대한 정보
→ 부모 요소에 접근할 수 있게 해준다.
   → context를 이용해 상위에 있는 변수나 함수에 접근 할 수 있다.
→ 위치 정보를 알려줄 수 있다.

<aside>
💡 ! ⇒ 난 확신해! 실행하도록 해!

</aside>

### initState()

build 하기 전에 실행 됨

→ 변수 초기화 할때

→ API 불러올 때 사용됨

```dart
@override
void initState(){
 super.initState();
}
```

### dispose()

위젯이 UI에서 사라질때 호출.

→ 화면상에서 위젯이 사라질때 → 위젯 트리에서 사라질 때

```dart
@override
void dispose(){
 super.dispose();
}
```

### Timer

```dart
int totalSeconds = 1500;
  late Timer timer;

  void onTick(Timer timer){
    setState(() {
      totalSeconds = totalSeconds - 1;
    });
  }

  void onStartPressed(){
    timer = Timer.periodic(const Duration(seconds: 1), onTick);
  }
```

```dart
Timer.periodic(duration, (timer){});
```

duration: 주기

(timer){}: 주기마다 실행 될 함
